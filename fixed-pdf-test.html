<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ä¿®å¾©ç‰ˆ PDF æ¸¬è©¦</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .btn { padding: 15px 30px; font-size: 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 10px; }
        .btn:hover { background: #c82333; }
        .result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <h1>ğŸ”§ ä¿®å¾©ç‰ˆ PDF ä¸­æ–‡è½‰æ›æ¸¬è©¦</h1>
    <p>ç›´æ¥ä½¿ç”¨ä¿®å¾©çš„è½‰æ›é‚è¼¯ç”ŸæˆPDF</p>
    
    <button class="btn" onclick="testFixedPDF()">ğŸš€ æ¸¬è©¦ä¿®å¾©ç‰ˆ PDF</button>
    
    <div id="results"></div>

    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <script>
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `
                <strong>${new Date().toLocaleTimeString()}</strong> - ${message}
            `;
            document.getElementById('results').appendChild(div);
        }

        // ä¿®å¾©ç‰ˆçš„ ASCII è½‰æ›å‡½æ•¸
        function convertToASCII(text) {
            if (!text) return text;
            
            log('é–‹å§‹è½‰æ›æ–‡å­—: ' + text.substring(0, 50) + '...');
            
            try {
                const translationMap = {
                    // å®Œæ•´çŸ­èªå„ªå…ˆ
                    'æœ€çµ‚é©—è­‰æ¸¬è©¦æ–‡ä»¶': 'Final Verification Test Document',
                    'æœ€çµ‚é©—è­‰æ¸¬è©¦': 'Final Verification Test',
                    'é€™æ˜¯ä¸€å€‹ç”¨æ–¼é©—è­‰ PDF è½‰æ›åŠŸèƒ½çš„æ¸¬è©¦æ–‡ä»¶': 'This is a test document for verifying PDF conversion functionality',
                    'åŠŸèƒ½é©—è­‰é …ç›®': 'Function Verification Items',
                    'ä¸­æ–‡å­—ç¬¦æ”¯æ´æ¸¬è©¦': 'Chinese character support test',
                    'ç‰¹æ®Šå­—ç¬¦è™•ç†': 'Special character processing',
                    'å¤šæ®µè½æ ¼å¼é©—è­‰': 'Multi-paragraph format verification',
                    'é•·æ–‡æœ¬è™•ç†èƒ½åŠ›æ¸¬è©¦': 'Long text processing capability test',
                    'æ¸¬è©¦æ™‚é–“': 'Test time',
                    
                    // å€‹åˆ¥è©å½™
                    'æ¸¬è©¦': 'test',
                    'æ–‡ä»¶': 'document',
                    'è½‰æ›': 'convert',
                    'åŠŸèƒ½': 'function',
                    'é©—è­‰': 'verify',
                    'æ”¯æ´': 'support',
                    'è™•ç†': 'process',
                    'æ ¼å¼': 'format',
                    'æ™‚é–“': 'time',
                    'çš„': ' ',
                    'å’Œ': ' and ',
                    'ï¼š': ': ',
                    'ï¼Œ': ', ',
                    'ã€‚': '. ',
                    'â€¢': '* ',
                    'ï¼ˆ': ' (',
                    'ï¼‰': ') '
                };
                
                let result = text;
                
                // æŒ‰é•·åº¦æ’åºï¼Œå…ˆè™•ç†é•·çŸ­èª
                const sortedKeys = Object.keys(translationMap).sort((a, b) => b.length - a.length);
                
                for (const chinese of sortedKeys) {
                    const before = result;
                    result = result.split(chinese).join(translationMap[chinese]);
                    if (before !== result) {
                        log(`âœ… è½‰æ›: "${chinese}" â†’ "${translationMap[chinese]}"`);
                    }
                }
                
                // ç§»é™¤å‰©é¤˜ä¸­æ–‡å­—ç¬¦
                result = result.replace(/[\u4e00-\u9fff]/g, ' ');
                
                // æ¸…ç†å¤šé¤˜ç©ºæ ¼
                result = result.replace(/\s+/g, ' ').trim();
                
                log('âœ… è½‰æ›å®Œæˆ: ' + result.substring(0, 100) + '...');
                return result;
                
            } catch (error) {
                log('âŒ è½‰æ›éŒ¯èª¤: ' + error.message, 'error');
                return text.replace(/[^\x00-\x7F]/g, ' ').replace(/\s+/g, ' ').trim();
            }
        }

        async function testFixedPDF() {
            log('ğŸ”„ é–‹å§‹ä¿®å¾©ç‰ˆPDFæ¸¬è©¦...');
            
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // æ¸¬è©¦å…§å®¹ï¼ˆä¸­æ–‡ï¼‰
                const originalTitle = 'æœ€çµ‚é©—è­‰æ¸¬è©¦æ–‡ä»¶';
                const originalContent = `é€™æ˜¯ä¸€å€‹ç”¨æ–¼é©—è­‰ PDF è½‰æ›åŠŸèƒ½çš„æ¸¬è©¦æ–‡ä»¶ã€‚

åŠŸèƒ½é©—è­‰é …ç›®ï¼š
â€¢ ä¸­æ–‡å­—ç¬¦æ”¯æ´æ¸¬è©¦
â€¢ ç‰¹æ®Šå­—ç¬¦è™•ç†ï¼š& < > " '
â€¢ å¤šæ®µè½æ ¼å¼é©—è­‰
â€¢ é•·æ–‡æœ¬è™•ç†èƒ½åŠ›æ¸¬è©¦

æ¸¬è©¦æ™‚é–“ï¼š${new Date().toLocaleString()}`;

                log('ğŸ“ åŸå§‹æ¨™é¡Œ: ' + originalTitle);
                
                // è½‰æ›ç‚ºASCII
                const asciiTitle = convertToASCII(originalTitle);
                const asciiContent = convertToASCII(originalContent);
                
                log('ğŸ“„ è½‰æ›å¾Œæ¨™é¡Œ: ' + asciiTitle, 'success');
                
                // ç”ŸæˆPDF
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(12);
                
                let yPosition = 20;
                const pageHeight = 280;
                const margin = 20;
                const lineHeight = 6;
                const pageWidth = 170;
                
                // æ·»åŠ æ¨™é¡Œ
                doc.setFontSize(16);
                doc.setFont('helvetica', 'bold');
                doc.text(asciiTitle, margin, yPosition);
                yPosition += 10;
                
                // æ·»åŠ å…§å®¹
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(12);
                
                const paragraphs = asciiContent.split('\n\n');
                
                paragraphs.forEach(paragraph => {
                    if (!paragraph.trim()) return;
                    
                    const lines = doc.splitTextToSize(paragraph.trim(), pageWidth);
                    
                    lines.forEach(line => {
                        if (yPosition > pageHeight - margin) {
                            doc.addPage();
                            yPosition = margin;
                        }
                        
                        doc.text(line, margin, yPosition);
                        yPosition += lineHeight;
                    });
                    
                    yPosition += 3;
                });
                
                // é è…³
                doc.setFontSize(10);
                doc.setTextColor(100, 100, 100);
                doc.text('Page 1 of 1', margin, pageHeight + 5);
                doc.text('Generated: ' + new Date().toLocaleDateString(), pageWidth - 40, pageHeight + 5);
                
                // ç”Ÿæˆä¸¦ä¸‹è¼‰
                const pdfBlob = doc.output('blob');
                log('âœ… ä¿®å¾©ç‰ˆPDFç”ŸæˆæˆåŠŸ: ' + pdfBlob.size + ' bytes', 'success');
                
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fixed-conversion-test.pdf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                log('ğŸ“¥ ä¿®å¾©ç‰ˆPDFå·²ä¸‹è¼‰ - è«‹æª¢æŸ¥å…§å®¹æ˜¯å¦ç‚ºæ­£å¸¸è‹±æ–‡!', 'success');
                
            } catch (error) {
                log('âŒ éŒ¯èª¤: ' + error.message, 'error');
                console.error('PDFç”ŸæˆéŒ¯èª¤:', error);
            }
        }
    </script>
</body>
</html>