<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªå‹•åŒ–æ¸¬è©¦ - æª”æ¡ˆè½‰æ›å™¨</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .test-results { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .success { color: #28a745; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .warning { color: #ffc107; font-weight: bold; }
        .info { color: #17a2b8; }
        .test-section { border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0; }
        .test-status { padding: 5px 10px; border-radius: 4px; display: inline-block; margin: 5px 0; }
        .status-pass { background: #d4edda; color: #155724; }
        .status-fail { background: #f8d7da; color: #721c24; }
        .status-running { background: #d1ecf1; color: #0c5460; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; }
        .progress-bar { width: 100%; height: 20px; background: #e9ecef; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #007bff, #28a745); transition: width 0.3s; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>ğŸ§ª æª”æ¡ˆè½‰æ›å™¨è‡ªå‹•åŒ–æ¸¬è©¦</h1>
    
    <div class="test-section">
        <h2>ğŸš€ æ¸¬è©¦æ§åˆ¶</h2>
        <button onclick="runAllTests()" id="runTestBtn">åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦</button>
        <button onclick="clearResults()">æ¸…é™¤çµæœ</button>
        <button onclick="exportTestReport()">åŒ¯å‡ºæ¸¬è©¦å ±å‘Š</button>
        
        <div class="progress-bar">
            <div class="progress-fill" id="testProgress" style="width: 0%"></div>
        </div>
        <div id="progressText">æº–å‚™å°±ç·’</div>
    </div>

    <div id="testResults" class="test-results">
        <h3>æ¸¬è©¦çµæœå°‡é¡¯ç¤ºåœ¨é€™è£¡...</h3>
    </div>

    <!-- Load all necessary scripts -->
    <script src="assets/js/lib-loader.js"></script>
    <script src="assets/js/converters/image.js"></script>
    <script src="assets/js/converters/document.js"></script>
    <script src="assets/js/converters/spreadsheet.js"></script>
    <script src="assets/js/converters/presentation.js"></script>
    <script src="assets/js/app.js"></script>

    <script>
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            details: []
        };

        function updateProgress(current, total, message) {
            const percentage = (current / total) * 100;
            document.getElementById('testProgress').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${message} (${current}/${total})`;
        }

        function log(message, type = 'info', category = 'general') {
            const timestamp = new Date().toLocaleTimeString();
            const result = {
                timestamp,
                message,
                type,
                category
            };
            
            testResults.details.push(result);
            
            const className = type === 'success' ? 'success' : 
                             type === 'error' ? 'error' : 
                             type === 'warning' ? 'warning' : 'info';
            
            return `<div class="${className}">[${timestamp}] ${message}</div>`;
        }

        function createTestFile(name, content, type = 'text/plain') {
            return new File([content], name, { type });
        }

        async function testSystemComponents() {
            let output = '<div class="test-section"><h3>ğŸ”§ ç³»çµ±çµ„ä»¶æ¸¬è©¦</h3>';
            let componentsPassed = 0;
            const totalComponents = 6;

            // Test core classes
            const coreClasses = {
                'LibraryLoader': window.LibraryLoader,
                'DocumentConverter': window.DocumentConverter,
                'SpreadsheetConverter': window.SpreadsheetConverter,
                'PresentationConverter': window.PresentationConverter,
                'ImageConverter': window.ImageConverter,
                'FileConverter': window.FileConverter
            };

            for (const [name, cls] of Object.entries(coreClasses)) {
                if (cls && typeof cls === 'function') {
                    output += log(`âœ… ${name} é¡åˆ¥å¯ç”¨`, 'success', 'system');
                    componentsPassed++;
                } else {
                    output += log(`âŒ ${name} é¡åˆ¥ä¸å¯ç”¨`, 'error', 'system');
                }
            }

            const systemScore = (componentsPassed / totalComponents) * 100;
            output += `<div class="status-${systemScore === 100 ? 'pass' : 'fail'} test-status">ç³»çµ±çµ„ä»¶æ¸¬è©¦: ${componentsPassed}/${totalComponents} é€šé (${systemScore.toFixed(1)}%)</div>`;
            output += '</div>';
            
            return { output, passed: componentsPassed === totalComponents };
        }

        async function testLibraryLoading() {
            let output = '<div class="test-section"><h3>ğŸ“š å‡½å¼åº«è¼‰å…¥æ¸¬è©¦</h3>';
            let librariesLoaded = 0;
            
            if (!window.libLoader) {
                output += log('âŒ LibraryLoader ä¸å¯ç”¨', 'error', 'libraries');
                output += '</div>';
                return { output, passed: false };
            }

            const criticalLibs = ['jspdf', 'sheetjs'];
            
            for (const libName of criticalLibs) {
                try {
                    output += log(`ğŸ“¦ æ­£åœ¨è¼‰å…¥ ${libName}...`, 'info', 'libraries');
                    await window.libLoader.loadLibrary(libName);
                    output += log(`âœ… ${libName} è¼‰å…¥æˆåŠŸ`, 'success', 'libraries');
                    librariesLoaded++;
                } catch (error) {
                    output += log(`âŒ ${libName} è¼‰å…¥å¤±æ•—: ${error.message}`, 'error', 'libraries');
                }
            }

            const libScore = (librariesLoaded / criticalLibs.length) * 100;
            output += `<div class="status-${libScore >= 50 ? 'pass' : 'fail'} test-status">å‡½å¼åº«æ¸¬è©¦: ${librariesLoaded}/${criticalLibs.length} è¼‰å…¥æˆåŠŸ (${libScore.toFixed(1)}%)</div>`;
            output += '</div>';
            
            return { output, passed: librariesLoaded >= criticalLibs.length / 2 };
        }

        async function testDocumentConversion() {
            let output = '<div class="test-section"><h3>ğŸ“„ æ–‡æ›¸è½‰æ›æ¸¬è©¦</h3>';
            let conversionsPassed = 0;
            const formats = ['txt', 'html', 'pdf', 'docx'];

            const testContent = {
                title: 'æ¸¬è©¦æ–‡ä»¶',
                content: 'é€™æ˜¯ä¸€å€‹æ¸¬è©¦æ–‡ä»¶ï¼Œç”¨ä¾†é©—è­‰æ–‡æ›¸è½‰æ›åŠŸèƒ½ã€‚\n\nåŒ…å«ä¸­æ–‡å­—ç¬¦å’ŒåŸºæœ¬æ ¼å¼ã€‚',
                originalHtml: '<h1>æ¸¬è©¦æ–‡ä»¶</h1><p>é€™æ˜¯ä¸€å€‹æ¸¬è©¦æ–‡ä»¶ã€‚</p>'
            };

            for (const format of formats) {
                try {
                    output += log(`ğŸ”„ æ¸¬è©¦è½‰æ›ç‚º ${format.toUpperCase()}...`, 'info', 'document');
                    const blob = await DocumentConverter.convertToFormat(testContent, format);
                    
                    if (blob && blob.size > 0) {
                        output += log(`âœ… ${format.toUpperCase()} è½‰æ›æˆåŠŸ (${blob.size} bytes)`, 'success', 'document');
                        conversionsPassed++;
                    } else {
                        output += log(`âŒ ${format.toUpperCase()} è½‰æ›ç”¢ç”Ÿç©ºæª”æ¡ˆ`, 'error', 'document');
                    }
                } catch (error) {
                    output += log(`âŒ ${format.toUpperCase()} è½‰æ›å¤±æ•—: ${error.message}`, 'error', 'document');
                }
            }

            const docScore = (conversionsPassed / formats.length) * 100;
            output += `<div class="status-${docScore >= 75 ? 'pass' : 'fail'} test-status">æ–‡æ›¸è½‰æ›æ¸¬è©¦: ${conversionsPassed}/${formats.length} æˆåŠŸ (${docScore.toFixed(1)}%)</div>`;
            output += '</div>';

            return { output, passed: conversionsPassed >= formats.length * 0.75 };
        }

        async function testSpreadsheetConversion() {
            let output = '<div class="test-section"><h3>ğŸ“Š è¡¨å–®è½‰æ›æ¸¬è©¦</h3>';
            let conversionsPassed = 0;
            const formats = ['csv', 'xlsx', 'json', 'html'];

            // Create test CSV data
            const csvContent = 'å§“å,å¹´é½¡,åŸå¸‚\nå¼µä¸‰,25,å°åŒ—\næå››,30,å°ä¸­\nç‹äº”,35,é«˜é›„';
            const csvFile = createTestFile('test.csv', csvContent, 'text/csv');

            try {
                // First parse the CSV
                output += log('ğŸ“Š è§£ææ¸¬è©¦ CSV æª”æ¡ˆ...', 'info', 'spreadsheet');
                const parsedData = await SpreadsheetConverter.parseSpreadsheetData(csvFile);
                
                if (parsedData.rowCount > 0) {
                    output += log(`âœ… CSV è§£ææˆåŠŸ: ${parsedData.rowCount} è¡Œ`, 'success', 'spreadsheet');
                    
                    // Test conversions
                    for (const format of formats) {
                        try {
                            output += log(`ğŸ”„ æ¸¬è©¦è½‰æ›ç‚º ${format.toUpperCase()}...`, 'info', 'spreadsheet');
                            const blob = await SpreadsheetConverter.convertToFormat(parsedData, format);
                            
                            if (blob && blob.size > 0) {
                                output += log(`âœ… ${format.toUpperCase()} è½‰æ›æˆåŠŸ (${blob.size} bytes)`, 'success', 'spreadsheet');
                                conversionsPassed++;
                            } else {
                                output += log(`âŒ ${format.toUpperCase()} è½‰æ›ç”¢ç”Ÿç©ºæª”æ¡ˆ`, 'error', 'spreadsheet');
                            }
                        } catch (error) {
                            output += log(`âŒ ${format.toUpperCase()} è½‰æ›å¤±æ•—: ${error.message}`, 'error', 'spreadsheet');
                        }
                    }
                } else {
                    output += log('âŒ CSV è§£æå¤±æ•—: ç„¡è³‡æ–™', 'error', 'spreadsheet');
                }
            } catch (error) {
                output += log(`âŒ CSV è§£æéŒ¯èª¤: ${error.message}`, 'error', 'spreadsheet');
            }

            const sheetScore = (conversionsPassed / formats.length) * 100;
            output += `<div class="status-${sheetScore >= 75 ? 'pass' : 'fail'} test-status">è¡¨å–®è½‰æ›æ¸¬è©¦: ${conversionsPassed}/${formats.length} æˆåŠŸ (${sheetScore.toFixed(1)}%)</div>`;
            output += '</div>';

            return { output, passed: conversionsPassed >= formats.length * 0.75 };
        }

        async function testPresentationConversion() {
            let output = '<div class="test-section"><h3>ğŸ¯ ç°¡å ±è½‰æ›æ¸¬è©¦</h3>';
            let conversionsPassed = 0;
            const formats = ['pdf', 'html', 'txt', 'md'];

            const testPresentation = {
                title: 'æ¸¬è©¦ç°¡å ±',
                slides: [
                    {
                        slideNumber: 1,
                        title: 'ç°¡å ±æ¨™é¡Œ',
                        content: ['é€™æ˜¯ç¬¬ä¸€å¼µæŠ•å½±ç‰‡', 'åŒ…å«æ¸¬è©¦å…§å®¹'],
                        notes: 'é€™æ˜¯å‚™è¨»'
                    },
                    {
                        slideNumber: 2,
                        title: 'å…§å®¹é é¢',
                        content: ['é …ç›®ä¸€', 'é …ç›®äºŒ', 'é …ç›®ä¸‰'],
                        notes: 'ç¬¬äºŒå¼µæŠ•å½±ç‰‡çš„å‚™è¨»'
                    }
                ],
                fileName: 'æ¸¬è©¦ç°¡å ±'
            };

            for (const format of formats) {
                try {
                    output += log(`ğŸ”„ æ¸¬è©¦ç°¡å ±è½‰æ›ç‚º ${format.toUpperCase()}...`, 'info', 'presentation');
                    const blob = await PresentationConverter.convertToFormat(testPresentation, format);
                    
                    if (blob && blob.size > 0) {
                        output += log(`âœ… ${format.toUpperCase()} è½‰æ›æˆåŠŸ (${blob.size} bytes)`, 'success', 'presentation');
                        conversionsPassed++;
                    } else {
                        output += log(`âŒ ${format.toUpperCase()} è½‰æ›ç”¢ç”Ÿç©ºæª”æ¡ˆ`, 'error', 'presentation');
                    }
                } catch (error) {
                    output += log(`âŒ ${format.toUpperCase()} è½‰æ›å¤±æ•—: ${error.message}`, 'error', 'presentation');
                }
            }

            const presentationScore = (conversionsPassed / formats.length) * 100;
            output += `<div class="status-${presentationScore >= 75 ? 'pass' : 'fail'} test-status">ç°¡å ±è½‰æ›æ¸¬è©¦: ${conversionsPassed}/${formats.length} æˆåŠŸ (${presentationScore.toFixed(1)}%)</div>`;
            output += '</div>';

            return { output, passed: conversionsPassed >= formats.length * 0.75 };
        }

        async function runAllTests() {
            const resultsDiv = document.getElementById('testResults');
            const runButton = document.getElementById('runTestBtn');
            
            runButton.disabled = true;
            runButton.textContent = 'æ¸¬è©¦é€²è¡Œä¸­...';
            
            testResults = { total: 0, passed: 0, failed: 0, details: [] };
            
            let allOutput = `<h3>ğŸ§ª è‡ªå‹•åŒ–æ¸¬è©¦å ±å‘Š</h3><p>é–‹å§‹æ™‚é–“: ${new Date().toLocaleString()}</p>`;
            
            const tests = [
                { name: 'ç³»çµ±çµ„ä»¶æ¸¬è©¦', func: testSystemComponents },
                { name: 'å‡½å¼åº«è¼‰å…¥æ¸¬è©¦', func: testLibraryLoading },
                { name: 'æ–‡æ›¸è½‰æ›æ¸¬è©¦', func: testDocumentConversion },
                { name: 'è¡¨å–®è½‰æ›æ¸¬è©¦', func: testSpreadsheetConversion },
                { name: 'ç°¡å ±è½‰æ›æ¸¬è©¦', func: testPresentationConversion }
            ];
            
            for (let i = 0; i < tests.length; i++) {
                const test = tests[i];
                updateProgress(i, tests.length, `åŸ·è¡Œ ${test.name}...`);
                
                try {
                    const result = await test.func();
                    allOutput += result.output;
                    testResults.total++;
                    if (result.passed) {
                        testResults.passed++;
                    } else {
                        testResults.failed++;
                    }
                } catch (error) {
                    allOutput += `<div class="error">âŒ ${test.name} åŸ·è¡Œå¤±æ•—: ${error.message}</div>`;
                    testResults.total++;
                    testResults.failed++;
                }
                
                // Update display
                resultsDiv.innerHTML = allOutput;
                
                // Small delay for UI updates
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            updateProgress(tests.length, tests.length, 'æ¸¬è©¦å®Œæˆ');
            
            // Add summary
            const successRate = (testResults.passed / testResults.total) * 100;
            const summaryClass = successRate >= 80 ? 'status-pass' : successRate >= 60 ? 'warning' : 'status-fail';
            
            allOutput += `<div class="test-section">
                <h3>ğŸ“Š æ¸¬è©¦ç¸½çµ</h3>
                <div class="${summaryClass} test-status">
                    ç¸½æ¸¬è©¦: ${testResults.total} | é€šé: ${testResults.passed} | å¤±æ•—: ${testResults.failed} | æˆåŠŸç‡: ${successRate.toFixed(1)}%
                </div>
                <p>çµæŸæ™‚é–“: ${new Date().toLocaleString()}</p>
            </div>`;
            
            resultsDiv.innerHTML = allOutput;
            
            runButton.disabled = false;
            runButton.textContent = 'é‡æ–°åŸ·è¡Œæ¸¬è©¦';
            
            console.log('ğŸ‰ è‡ªå‹•åŒ–æ¸¬è©¦å®Œæˆ', testResults);
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '<h3>æ¸¬è©¦çµæœå°‡é¡¯ç¤ºåœ¨é€™è£¡...</h3>';
            document.getElementById('testProgress').style.width = '0%';
            document.getElementById('progressText').textContent = 'æº–å‚™å°±ç·’';
            testResults = { total: 0, passed: 0, failed: 0, details: [] };
        }

        function exportTestReport() {
            if (testResults.details.length === 0) {
                alert('æ²’æœ‰æ¸¬è©¦çµæœå¯ä»¥åŒ¯å‡ºï¼Œè«‹å…ˆåŸ·è¡Œæ¸¬è©¦ã€‚');
                return;
            }
            
            const report = `æª”æ¡ˆè½‰æ›å™¨æ¸¬è©¦å ±å‘Š
ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString()}
æˆåŠŸç‡: ${((testResults.passed / testResults.total) * 100).toFixed(1)}%
ç¸½æ¸¬è©¦: ${testResults.total} | é€šé: ${testResults.passed} | å¤±æ•—: ${testResults.failed}

è©³ç´°çµæœ:
${testResults.details.map(detail => 
    `[${detail.timestamp}] [${detail.category}] [${detail.type}] ${detail.message}`
).join('\n')}

æ¸¬è©¦ç’°å¢ƒ:
- ç€è¦½å™¨: ${navigator.userAgent}
- æ™‚é–“: ${new Date().toLocaleString()}
`;
            
            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `file-converter-test-report-${new Date().getTime()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Auto-initialize
        window.addEventListener('load', function() {
            console.log('ğŸš€ è‡ªå‹•åŒ–æ¸¬è©¦ç³»çµ±å°±ç·’');
        });
    </script>
</body>
</html>